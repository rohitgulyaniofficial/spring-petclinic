name: AWS Smoke Deploy (GHCR Image)

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (default: git sha)"
        required: false
        type: string
      skip_deploy:
        description: "Build + push only (skip deployment trigger)"
        required: true
        type: boolean
        default: false
  push:
    branches: [ main ]

permissions:
  contents: read
  id-token: write

concurrency:
  group: aws-smoke-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-and-push-ghcr:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_ref: ${{ steps.meta.outputs.image_ref }}
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      - name: Resolve image metadata
        id: meta
        env:
          INPUT_IMAGE_TAG: ${{ github.event.inputs.image_tag }}
        run: |
          REPO_LOWER=$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')
          IMAGE_TAG="${INPUT_IMAGE_TAG:-${GITHUB_SHA}}"
          IMAGE_REF="ghcr.io/${REPO_LOWER}:${IMAGE_TAG}"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and publish image to GHCR
        run: |
          ./mvnw -B spring-boot:build-image \
            -Dspring-boot.build-image.imageName=${{ steps.meta.outputs.image_ref }} \
            -Dspring-boot.build-image.publish=true

      - name: Publish build metadata
        run: |
          {
            echo "## GHCR image"
            echo "- Image: \`${{ steps.meta.outputs.image_ref }}\`"
            echo "- Source commit: \`${GITHUB_SHA}\`"
          } >> "$GITHUB_STEP_SUMMARY"

  smoke-deploy-and-verify:
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && !inputs.skip_deploy) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    needs: build-and-push-ghcr
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      SMOKE_URL: ${{ vars.SMOKE_URL }}
      CLOUDWATCH_LOG_GROUP: ${{ vars.CLOUDWATCH_LOG_GROUP }}
      CLOUDWATCH_LOG_QUERY: ${{ vars.CLOUDWATCH_LOG_QUERY }}
      DEPLOY_TRIGGER_COMMAND: ${{ vars.DEPLOY_TRIGGER_COMMAND }}
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Trigger infrastructure deployment
        if: ${{ env.DEPLOY_TRIGGER_COMMAND != '' }}
        run: |
          set -euo pipefail
          # Execute the deploy command from the repository variable.
          # Note: For enhanced security, consider using a checked-in script
          # instead of a dynamic command string.
          eval "${DEPLOY_TRIGGER_COMMAND}"

      - name: Wait for application health endpoint
        run: |
          set -euo pipefail
          if [ -z "${SMOKE_URL}" ]; then
            echo "SMOKE_URL repo variable must be set"
            exit 1
          fi

          for i in {1..30}; do
            status=$(curl -s -o /dev/null -w "%{http_code}" "${SMOKE_URL}" || true)
            if [ "${status}" = "200" ]; then
              echo "Smoke test passed"
              exit 0
            fi
            echo "Attempt ${i}: ${SMOKE_URL} returned ${status}; retrying in 10s"
            sleep 10
          done

          echo "Smoke test failed"
          exit 1

      - name: Verify Fluent Bit forwarding to CloudWatch
        run: |
          set -euo pipefail
          if [ -z "${CLOUDWATCH_LOG_GROUP}" ] || [ -z "${CLOUDWATCH_LOG_QUERY}" ]; then
            echo "CLOUDWATCH_LOG_GROUP and CLOUDWATCH_LOG_QUERY repo variables are required"
            exit 1
          fi

          now=$(date +%s)
          start=$(( now - 900 ))

          matches=$(aws logs filter-log-events \
            --region "${AWS_REGION}" \
            --log-group-name "${CLOUDWATCH_LOG_GROUP}" \
            --start-time "$((start * 1000))" \
            --filter-pattern "${CLOUDWATCH_LOG_QUERY}" \
            --max-items 1 \
            --output text \
            --query 'length(events)' || echo "0")

          if [ -z "${matches}" ] || [ "${matches}" = "None" ] || [ "${matches}" = "0" ]; then
            echo "No matching app logs found in CloudWatch."
            exit 1
          fi

          {
            echo "## Smoke verification"
            echo "- Endpoint: \`${SMOKE_URL}\`"
            echo "- CloudWatch group: \`${CLOUDWATCH_LOG_GROUP}\`"
            echo "- Query: \`${CLOUDWATCH_LOG_QUERY}\`"
            echo "- Result: app logs found (fluent-bit path validated)"
          } >> "$GITHUB_STEP_SUMMARY"
